diff -Naur chromium-89.0.4389.90.orig/components/chromeos_camera/gpu_mjpeg_decode_accelerator_factory.cc chromium-89.0.4389.90/components/chromeos_camera/gpu_mjpeg_decode_accelerator_factory.cc
--- chromium-89.0.4389.90.orig/components/chromeos_camera/gpu_mjpeg_decode_accelerator_factory.cc	2021-03-13 00:57:22.000000000 +0100
+++ chromium-89.0.4389.90/components/chromeos_camera/gpu_mjpeg_decode_accelerator_factory.cc	2021-04-02 09:39:45.870651498 +0200
@@ -13,7 +13,8 @@
 #include "media/base/media_switches.h"
 #include "media/gpu/buildflags.h"
 
-#if BUILDFLAG(USE_V4L2_CODEC) && defined(ARCH_CPU_ARM_FAMILY)
+#if BUILDFLAG(USE_V4L2_CODEC) && defined(ARCH_CPU_ARM_FAMILY) && \
+    !BUILDFLAG(USE_LINUX_V4L2)
 #define USE_V4L2_MJPEG_DECODE_ACCELERATOR
 #endif
 
diff -Naur chromium-89.0.4389.90.orig/media/gpu/args.gni chromium-89.0.4389.90/media/gpu/args.gni
--- chromium-89.0.4389.90.orig/media/gpu/args.gni	2021-03-13 00:57:26.000000000 +0100
+++ chromium-89.0.4389.90/media/gpu/args.gni	2021-04-02 09:39:45.870651498 +0200
@@ -13,6 +13,10 @@
   # platforms which have v4l2 hardware encoder / decoder.
   use_v4l2_codec = false
 
+  # Indicates that only definitions available in the mainline linux kernel
+  # will be used.
+  use_linux_v4l2_only = false
+
   # Indicates if Video4Linux2 AML encoder is used. This is used for AML
   # platforms which have v4l2 hardware encoder
   use_v4l2_codec_aml = false
diff -Naur chromium-89.0.4389.90.orig/media/gpu/BUILD.gn chromium-89.0.4389.90/media/gpu/BUILD.gn
--- chromium-89.0.4389.90.orig/media/gpu/BUILD.gn	2021-03-13 00:57:26.000000000 +0100
+++ chromium-89.0.4389.90/media/gpu/BUILD.gn	2021-04-02 09:39:45.870651498 +0200
@@ -20,6 +20,7 @@
     "USE_VAAPI_IMAGE_CODECS=$use_vaapi_image_codecs",
     "USE_V4L2_CODEC=$use_v4l2_codec",
     "USE_LIBV4L2=$use_v4lplugin",
+    "USE_LINUX_V4L2=$use_linux_v4l2_only",
   ]
 }
 
diff -Naur chromium-89.0.4389.90.orig/media/gpu/gpu_video_decode_accelerator_factory.cc chromium-89.0.4389.90/media/gpu/gpu_video_decode_accelerator_factory.cc
--- chromium-89.0.4389.90.orig/media/gpu/gpu_video_decode_accelerator_factory.cc	2021-03-13 00:57:26.000000000 +0100
+++ chromium-89.0.4389.90/media/gpu/gpu_video_decode_accelerator_factory.cc	2021-04-02 09:39:45.870651498 +0200
@@ -26,7 +26,9 @@
 #endif
 #if BUILDFLAG(USE_V4L2_CODEC)
 #include "media/gpu/v4l2/v4l2_device.h"
+#if !BUILDFLAG(USE_LINUX_V4L2)
 #include "media/gpu/v4l2/v4l2_slice_video_decode_accelerator.h"
+#endif
 #include "media/gpu/v4l2/v4l2_video_decode_accelerator.h"
 #include "ui/gl/gl_surface_egl.h"
 #endif
@@ -63,10 +65,12 @@
   vda_profiles = V4L2VideoDecodeAccelerator::GetSupportedProfiles();
   GpuVideoAcceleratorUtil::InsertUniqueDecodeProfiles(
       vda_profiles, &capabilities.supported_profiles);
+#if !BUILDFLAG(USE_LINUX_V4L2)
   vda_profiles = V4L2SliceVideoDecodeAccelerator::GetSupportedProfiles();
   GpuVideoAcceleratorUtil::InsertUniqueDecodeProfiles(
       vda_profiles, &capabilities.supported_profiles);
 #endif
+#endif
 #if BUILDFLAG(USE_VAAPI)
   vda_profiles = VaapiVideoDecodeAccelerator::GetSupportedProfiles(workarounds);
   GpuVideoAcceleratorUtil::InsertUniqueDecodeProfiles(
@@ -147,8 +151,10 @@
 #endif
 #if BUILDFLAG(USE_V4L2_CODEC)
     &GpuVideoDecodeAcceleratorFactory::CreateV4L2VDA,
+#if !BUILDFLAG(USE_LINUX_V4L2)
     &GpuVideoDecodeAcceleratorFactory::CreateV4L2SVDA,
 #endif
+#endif
 #if defined(OS_MAC)
     &GpuVideoDecodeAcceleratorFactory::CreateVTVDA,
 #endif
@@ -196,6 +202,7 @@
   return decoder;
 }
 
+#if !BUILDFLAG(USE_LINUX_V4L2)
 std::unique_ptr<VideoDecodeAccelerator>
 GpuVideoDecodeAcceleratorFactory::CreateV4L2SVDA(
     const gpu::GpuDriverBugWorkarounds& workarounds,
@@ -211,6 +218,7 @@
   return decoder;
 }
 #endif
+#endif
 
 #if BUILDFLAG(USE_VAAPI)
 std::unique_ptr<VideoDecodeAccelerator>
diff -Naur chromium-89.0.4389.90.orig/media/gpu/gpu_video_decode_accelerator_factory.h chromium-89.0.4389.90/media/gpu/gpu_video_decode_accelerator_factory.h
--- chromium-89.0.4389.90.orig/media/gpu/gpu_video_decode_accelerator_factory.h	2021-03-13 00:57:26.000000000 +0100
+++ chromium-89.0.4389.90/media/gpu/gpu_video_decode_accelerator_factory.h	2021-04-02 09:39:45.870651498 +0200
@@ -92,11 +92,13 @@
       const gpu::GpuDriverBugWorkarounds& workarounds,
       const gpu::GpuPreferences& gpu_preferences,
       MediaLog* media_log) const;
+#if !BUILDFLAG(USE_LINUX_V4L2)
   std::unique_ptr<VideoDecodeAccelerator> CreateV4L2SVDA(
       const gpu::GpuDriverBugWorkarounds& workarounds,
       const gpu::GpuPreferences& gpu_preferences,
       MediaLog* media_log) const;
 #endif
+#endif
 #if BUILDFLAG(USE_VAAPI)
   std::unique_ptr<VideoDecodeAccelerator> CreateVaapiVDA(
       const gpu::GpuDriverBugWorkarounds& workarounds,
diff -Naur chromium-89.0.4389.90.orig/media/gpu/v4l2/BUILD.gn chromium-89.0.4389.90/media/gpu/v4l2/BUILD.gn
--- chromium-89.0.4389.90.orig/media/gpu/v4l2/BUILD.gn	2021-03-13 00:57:26.000000000 +0100
+++ chromium-89.0.4389.90/media/gpu/v4l2/BUILD.gn	2021-04-02 09:39:45.870651498 +0200
@@ -28,21 +28,12 @@
     "buffer_affinity_tracker.h",
     "generic_v4l2_device.cc",
     "generic_v4l2_device.h",
-    "v4l2_decode_surface.cc",
-    "v4l2_decode_surface.h",
-    "v4l2_decode_surface_handler.h",
     "v4l2_device.cc",
     "v4l2_device.h",
     "v4l2_device_poller.cc",
     "v4l2_device_poller.h",
-    "v4l2_h264_accelerator.cc",
-    "v4l2_h264_accelerator.h",
-    "v4l2_h264_accelerator_legacy.cc",
-    "v4l2_h264_accelerator_legacy.h",
     "v4l2_image_processor_backend.cc",
     "v4l2_image_processor_backend.h",
-    "v4l2_slice_video_decode_accelerator.cc",
-    "v4l2_slice_video_decode_accelerator.h",
     "v4l2_stateful_workaround.cc",
     "v4l2_stateful_workaround.h",
     "v4l2_vda_helpers.cc",
@@ -55,18 +46,32 @@
     "v4l2_video_decoder_backend.h",
     "v4l2_video_decoder_backend_stateful.cc",
     "v4l2_video_decoder_backend_stateful.h",
-    "v4l2_video_decoder_backend_stateless.cc",
-    "v4l2_video_decoder_backend_stateless.h",
     "v4l2_video_encode_accelerator.cc",
     "v4l2_video_encode_accelerator.h",
-    "v4l2_vp8_accelerator.cc",
-    "v4l2_vp8_accelerator.h",
-    "v4l2_vp8_accelerator_legacy.cc",
-    "v4l2_vp8_accelerator_legacy.h",
-    "v4l2_vp9_accelerator_legacy.cc",
-    "v4l2_vp9_accelerator_legacy.h",
   ]
 
+  if (!use_linux_v4l2_only) {
+    sources += [
+      "v4l2_decode_surface.cc",
+      "v4l2_decode_surface.h",
+      "v4l2_decode_surface_handler.h",
+      "v4l2_h264_accelerator.cc",
+      "v4l2_h264_accelerator.h",
+      "v4l2_h264_accelerator_legacy.cc",
+      "v4l2_h264_accelerator_legacy.h",
+      "v4l2_slice_video_decode_accelerator.cc",
+      "v4l2_slice_video_decode_accelerator.h",
+      "v4l2_video_decoder_backend_stateless.cc",
+      "v4l2_video_decoder_backend_stateless.h",
+      "v4l2_vp8_accelerator.cc",
+      "v4l2_vp8_accelerator.h",
+      "v4l2_vp8_accelerator_legacy.cc",
+      "v4l2_vp8_accelerator_legacy.h",
+      "v4l2_vp9_accelerator_legacy.cc",
+      "v4l2_vp9_accelerator_legacy.h",
+    ]
+  }
+
   libs = [
     "EGL",
     "GLESv2",
diff -Naur chromium-89.0.4389.90.orig/media/gpu/v4l2/generic_v4l2_device.cc chromium-89.0.4389.90/media/gpu/v4l2/generic_v4l2_device.cc
--- chromium-89.0.4389.90.orig/media/gpu/v4l2/generic_v4l2_device.cc	2021-03-13 00:57:26.000000000 +0100
+++ chromium-89.0.4389.90/media/gpu/v4l2/generic_v4l2_device.cc	2021-04-02 09:39:45.870651498 +0200
@@ -415,7 +415,11 @@
     return false;
 
 #if BUILDFLAG(USE_LIBV4L2)
+#if BUILDFLAG(USE_LINUX_V4L2)
+  if (
+#else
   if (type == Type::kEncoder &&
+#endif
       HANDLE_EINTR(v4l2_fd_open(device_fd_.get(), V4L2_DISABLE_CONVERSION)) !=
           -1) {
     DVLOGF(3) << "Using libv4l2 for " << path;
diff -Naur chromium-89.0.4389.90.orig/media/gpu/v4l2/v4l2_device.cc chromium-89.0.4389.90/media/gpu/v4l2/v4l2_device.cc
--- chromium-89.0.4389.90.orig/media/gpu/v4l2/v4l2_device.cc	2021-03-13 00:57:26.000000000 +0100
+++ chromium-89.0.4389.90/media/gpu/v4l2/v4l2_device.cc	2021-04-02 09:39:45.871651513 +0200
@@ -784,7 +784,9 @@
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   DCHECK(buffer_data_);
 
+#if !BUILDFLAG(USE_LINUX_V4L2)
   buffer_data_->v4l2_buffer_.config_store = config_store;
+#endif
 }
 
 V4L2ReadableBuffer::V4L2ReadableBuffer(const struct v4l2_buffer& v4l2_buffer,
@@ -927,10 +929,12 @@
     return;
   }
 
+#if !BUILDFLAG(USE_LINUX_V4L2)
   if (reqbufs.capabilities & V4L2_BUF_CAP_SUPPORTS_REQUESTS) {
     supports_requests_ = true;
     DVLOGF(4) << "Queue supports request API.";
   }
+#endif
 }
 
 V4L2Queue::~V4L2Queue() {
@@ -1463,6 +1467,23 @@
 // static
 uint32_t V4L2Device::VideoCodecProfileToV4L2PixFmt(VideoCodecProfile profile,
                                                    bool slice_based) {
+#if BUILDFLAG(USE_LINUX_V4L2)
+  if (slice_based) {
+    LOG(ERROR) << "Slice not supported";
+    return 0;
+  }
+
+  if (profile >= H264PROFILE_MIN && profile <= H264PROFILE_MAX) {
+    return V4L2_PIX_FMT_H264;
+  } else if (profile >= VP8PROFILE_MIN && profile <= VP8PROFILE_MAX) {
+    return V4L2_PIX_FMT_VP8;
+  } else if (profile >= VP9PROFILE_MIN && profile <= VP9PROFILE_MAX) {
+    return V4L2_PIX_FMT_VP9;
+  } else {
+    LOG(ERROR) << "Unknown profile: " << GetProfileName(profile);
+    return 0;
+  }
+#else
   if (profile >= H264PROFILE_MIN && profile <= H264PROFILE_MAX) {
     if (slice_based)
       return V4L2_PIX_FMT_H264_SLICE;
@@ -1482,8 +1503,10 @@
     LOG(ERROR) << "Unknown profile: " << GetProfileName(profile);
     return 0;
   }
+#endif
 }
 
+#if !BUILDFLAG(USE_LINUX_V4L2)
 // static
 VideoCodecProfile V4L2Device::V4L2ProfileToVideoCodecProfile(VideoCodec codec,
                                                              uint32_t profile) {
@@ -1532,10 +1555,12 @@
   VLOGF(2) << "Unknown profile: " << profile;
   return VIDEO_CODEC_PROFILE_UNKNOWN;
 }
+#endif
 
 std::vector<VideoCodecProfile> V4L2Device::V4L2PixFmtToVideoCodecProfiles(
     uint32_t pix_fmt,
     bool is_encoder) {
+#if !BUILDFLAG(USE_LINUX_V4L2)
   auto get_supported_profiles = [this](
                                     VideoCodec codec,
                                     std::vector<VideoCodecProfile>* profiles) {
@@ -1606,6 +1631,27 @@
       VLOGF(1) << "Unhandled pixelformat " << FourccToString(pix_fmt);
       return {};
   }
+#else
+  std::vector<VideoCodecProfile> profiles;
+  switch (pix_fmt) {
+    case V4L2_PIX_FMT_H264:
+      profiles = {
+          H264PROFILE_BASELINE,
+          H264PROFILE_MAIN,
+          H264PROFILE_HIGH,
+      };
+      break;
+    case V4L2_PIX_FMT_VP8:
+      profiles = {VP8PROFILE_ANY};
+      break;
+    case V4L2_PIX_FMT_VP9:
+      profiles = {VP9PROFILE_PROFILE0};
+      break;
+    default:
+      VLOGF(1) << "Unhandled pixelformat " << FourccToString(pix_fmt);
+      return {};
+  }
+#endif
 
   // Erase duplicated profiles.
   std::sort(profiles.begin(), profiles.end());
@@ -1630,6 +1676,12 @@
     case V4L2_PIX_FMT_RGB32:
       return DRM_FORMAT_ARGB8888;
 
+#if !BUILDFLAG(USE_LINUX_V4L2)
+    case V4L2_PIX_FMT_MT21C:
+    case V4L2_PIX_FMT_MT21:
+      return DRM_FORMAT_MT21;
+#endif
+
     default:
       DVLOGF(1) << "Unrecognized format " << FourccToString(format);
       return 0;
@@ -2311,10 +2363,14 @@
     return false;
   }
 
+#if !BUILDFLAG(USE_LINUX_V4L2)
   ctrls->which = V4L2_CTRL_WHICH_REQUEST_VAL;
   ctrls->request_fd = request_fd_.get();
 
   return true;
+#else
+  return false;
+#endif
 }
 
 bool V4L2Request::ApplyQueueBuffer(struct v4l2_buffer* buffer) {
@@ -2326,10 +2382,14 @@
     return false;
   }
 
+#if !BUILDFLAG(USE_LINUX_V4L2)
   buffer->flags |= V4L2_BUF_FLAG_REQUEST_FD;
   buffer->request_fd = request_fd_.get();
 
   return true;
+#else
+  return false;
+#endif
 }
 
 bool V4L2Request::Submit() {
@@ -2340,7 +2400,11 @@
     return false;
   }
 
+#if !BUILDFLAG(USE_LINUX_V4L2)
   return HANDLE_EINTR(ioctl(request_fd_.get(), MEDIA_REQUEST_IOC_QUEUE)) == 0;
+#else
+  return false;
+#endif
 }
 
 bool V4L2Request::IsCompleted() {
@@ -2383,6 +2447,7 @@
     return false;
   }
 
+#if !BUILDFLAG(USE_LINUX_V4L2)
   // Reinit the request to make sure we can use it for a new submission.
   if (HANDLE_EINTR(ioctl(request_fd_.get(), MEDIA_REQUEST_IOC_REINIT)) < 0) {
     VPLOGF(1) << "Failed to reinit request.";
@@ -2390,6 +2455,9 @@
   }
 
   return true;
+#else
+  return false;
+#endif
 }
 
 V4L2RequestRefBase::V4L2RequestRefBase(V4L2RequestRefBase&& req_base) {
@@ -2464,6 +2532,7 @@
 base::Optional<base::ScopedFD> V4L2RequestsQueue::CreateRequestFD() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
 
+#if !BUILDFLAG(USE_LINUX_V4L2)
   int request_fd;
   int ret = HANDLE_EINTR(
         ioctl(media_fd_.get(), MEDIA_IOC_REQUEST_ALLOC, &request_fd));
@@ -2473,6 +2542,9 @@
   }
 
   return base::ScopedFD(request_fd);
+#else
+  return base::nullopt;
+#endif
 }
 
 base::Optional<V4L2RequestRef> V4L2RequestsQueue::GetFreeRequest() {
diff -Naur chromium-89.0.4389.90.orig/media/gpu/v4l2/v4l2_video_decoder.cc chromium-89.0.4389.90/media/gpu/v4l2/v4l2_video_decoder.cc
--- chromium-89.0.4389.90.orig/media/gpu/v4l2/v4l2_video_decoder.cc	2021-03-13 00:57:26.000000000 +0100
+++ chromium-89.0.4389.90/media/gpu/v4l2/v4l2_video_decoder.cc	2021-04-02 09:52:52.955647729 +0200
@@ -19,7 +19,10 @@
 #include "media/gpu/gpu_video_decode_accelerator_helpers.h"
 #include "media/gpu/macros.h"
 #include "media/gpu/v4l2/v4l2_video_decoder_backend_stateful.h"
+
+#if !BUILDFLAG(USE_LINUX_V4L2)
 #include "media/gpu/v4l2/v4l2_video_decoder_backend_stateless.h"
+#endif
 
 namespace media {
 
@@ -35,7 +38,9 @@
 
 // Input format V4L2 fourccs this class supports.
 constexpr uint32_t kSupportedInputFourccs[] = {
+#if !BUILDFLAG(USE_LINUX_V4L2)
     V4L2_PIX_FMT_H264_SLICE, V4L2_PIX_FMT_VP8_FRAME, V4L2_PIX_FMT_VP9_FRAME,
+#endif
     V4L2_PIX_FMT_H264,       V4L2_PIX_FMT_VP8,       V4L2_PIX_FMT_VP9,
 };
 
@@ -216,6 +221,7 @@
              << " and fourcc: " << FourccToString(input_format_fourcc);
     backend_ = std::make_unique<V4L2StatefulVideoDecoderBackend>(
         this, device_, profile, decoder_task_runner_);
+#if !BUILDFLAG(USE_LINUX_V4L2)
   } else {
     DCHECK_EQ(preferred_api_and_format.first, kStateless);
     VLOGF(1) << "Using a stateless API for profile: " << GetProfileName(profile)
@@ -223,6 +229,9 @@
     backend_ = std::make_unique<V4L2StatelessVideoDecoderBackend>(
         this, device_, profile, decoder_task_runner_);
   }
+#else
+  }
+#endif
 
   if (!backend_->Initialize()) {
     VLOGF(1) << "Failed to initialize backend.";
