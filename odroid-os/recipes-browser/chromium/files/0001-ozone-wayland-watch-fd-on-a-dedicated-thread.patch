From 13a6ed538c796d0411b2c158db4261f82f1b0f8f Mon Sep 17 00:00:00 2001
From: Maksim Sisov <msisov@igalia.com>
Date: Thu, 8 Apr 2021 14:33:40 +0300
Subject: [PATCH] ozone/wayland: watch fd on a dedicated thread.

Change-Id: I33fa21f84bb26592e97327c3f0a9c926868ad214
---
 .../platform/wayland/common/wayland_object.cc |   8 +
 .../platform/wayland/common/wayland_object.h  |  16 ++
 .../wayland/host/wayland_connection.cc        |  15 +-
 .../wayland/host/wayland_connection.h         |  14 ++
 .../host/wayland_connection_unittest.cc       |   1 +
 .../wayland/host/wayland_data_device_base.cc  |   3 +-
 .../wayland/host/wayland_event_source.cc      |  16 +-
 .../wayland/host/wayland_event_source.h       |  11 +-
 .../wayland/host/wayland_event_watcher.cc     | 160 +++++++++++++++---
 .../wayland/host/wayland_event_watcher.h      |  49 +++++-
 .../platform/wayland/host/wayland_keyboard.cc |   2 +-
 .../host/wayland_zaura_shell_unittest.cc      |   1 +
 .../platform/wayland/test/wayland_test.cc     |   2 +
 13 files changed, 255 insertions(+), 43 deletions(-)

diff --git a/ui/ozone/platform/wayland/common/wayland_object.cc b/ui/ozone/platform/wayland/common/wayland_object.cc
index 7a6c5e7b849c..fac3089e12a7 100644
--- a/ui/ozone/platform/wayland/common/wayland_object.cc
+++ b/ui/ozone/platform/wayland/common/wayland_object.cc
@@ -15,6 +15,7 @@
 #include <primary-selection-unstable-v1-client-protocol.h>
 #include <text-input-unstable-v1-client-protocol.h>
 #include <viewporter-client-protocol.h>
+#include <wayland-client-core.h>
 #include <wayland-drm-client-protocol.h>
 #include <xdg-decoration-unstable-v1-client-protocol.h>
 #include <xdg-foreign-unstable-v1-client-protocol.h>
@@ -154,6 +155,10 @@ void (*ObjectTraits<wl_data_source>::deleter)(wl_data_source*) =
 const wl_interface* ObjectTraits<wl_drm>::interface = &wl_drm_interface;
 void (*ObjectTraits<wl_drm>::deleter)(wl_drm*) = &wl_drm_destroy;
 
+const wl_interface* ObjectTraits<wl_event_queue>::interface = nullptr;
+void (*ObjectTraits<wl_event_queue>::deleter)(wl_event_queue*) =
+    &wl_event_queue_destroy;
+
 const wl_interface* ObjectTraits<wl_display>::interface = &wl_display_interface;
 void (*ObjectTraits<wl_display>::deleter)(wl_display*) = &wl_display_disconnect;
 
@@ -210,6 +215,9 @@ const wl_interface* ObjectTraits<struct wp_presentation_feedback>::interface =
 void (*ObjectTraits<struct wp_presentation_feedback>::deleter)(
     struct wp_presentation_feedback*) = &wp_presentation_feedback_destroy;
 
+const wl_interface* ObjectTraits<struct wl_proxy>::interface = nullptr;
+void (*ObjectTraits<wl_proxy>::deleter)(void*) = &wl_proxy_wrapper_destroy;
+
 const wl_interface* ObjectTraits<wp_viewport>::interface =
     &wp_viewport_interface;
 void (*ObjectTraits<wp_viewport>::deleter)(wp_viewport*) = &wp_viewport_destroy;
diff --git a/ui/ozone/platform/wayland/common/wayland_object.h b/ui/ozone/platform/wayland/common/wayland_object.h
index b06cf876f917..b0d3aafc3a2c 100644
--- a/ui/ozone/platform/wayland/common/wayland_object.h
+++ b/ui/ozone/platform/wayland/common/wayland_object.h
@@ -25,6 +25,7 @@ struct wl_data_device;
 struct wl_data_offer;
 struct wl_data_source;
 struct wl_drm;
+struct wl_event_queue;
 struct wl_keyboard;
 struct wl_output;
 struct wl_pointer;
@@ -39,6 +40,7 @@ struct wl_surface;
 struct wl_touch;
 struct wp_presentation;
 struct wp_presentation_feedback;
+struct wl_proxy;
 struct wp_viewport;
 struct wp_viewporter;
 struct xdg_wm_base;
@@ -183,6 +185,12 @@ struct ObjectTraits<wl_drm> {
   static void (*deleter)(wl_drm*);
 };
 
+template <>
+struct ObjectTraits<wl_event_queue> {
+  static const wl_interface* interface;
+  static void (*deleter)(wl_event_queue*);
+};
+
 template <>
 struct ObjectTraits<wl_display> {
   static const wl_interface* interface;
@@ -273,6 +281,13 @@ struct ObjectTraits<wp_presentation_feedback> {
   static void (*deleter)(wp_presentation_feedback*);
 };
 
+template <>
+struct ObjectTraits<wl_proxy> {
+  // Interface is null for proxy.
+  static const wl_interface* interface;
+  static void (*deleter)(void*);
+};
+
 template <>
 struct ObjectTraits<wp_viewport> {
   static const wl_interface* interface;
@@ -462,6 +477,7 @@ class Object : public std::unique_ptr<T, Deleter> {
 
 template <typename T>
 wl::Object<T> Bind(wl_registry* registry, uint32_t name, uint32_t version) {
+  DCHECK(ObjectTraits<T>::interface);
   return wl::Object<T>(static_cast<T*>(
       wl::bind_registry(registry, name, ObjectTraits<T>::interface, version)));
 }
diff --git a/ui/ozone/platform/wayland/host/wayland_connection.cc b/ui/ozone/platform/wayland/host/wayland_connection.cc
index 2dd529408ca8..3e01542d066b 100644
--- a/ui/ozone/platform/wayland/host/wayland_connection.cc
+++ b/ui/ozone/platform/wayland/host/wayland_connection.cc
@@ -104,7 +104,14 @@ bool WaylandConnection::Initialize() {
     return false;
   }
 
-  registry_.reset(wl_display_get_registry(display_.get()));
+  wrapped_display_.reset(
+      reinterpret_cast<wl_proxy*>(wl_proxy_create_wrapper(display())));
+  // Create a non-default event queue so that we wouldn't flush messages for
+  // client applications.
+  event_queue_.reset(wl_display_create_queue(display()));
+  wl_proxy_set_queue(wrapped_display_.get(), event_queue_.get());
+
+  registry_.reset(wl_display_get_registry(display_wrapper()));
   if (!registry_) {
     LOG(ERROR) << "Failed to get Wayland registry";
     return false;
@@ -113,13 +120,13 @@ bool WaylandConnection::Initialize() {
   // Now that the connection with the display server has been properly
   // estabilished, initialize the event source and input objects.
   DCHECK(!event_source_);
-  event_source_ =
-      std::make_unique<WaylandEventSource>(display(), wayland_window_manager());
+  event_source_ = std::make_unique<WaylandEventSource>(
+      display(), event_queue_.get(), wayland_window_manager());
 
   wl_registry_add_listener(registry_.get(), &registry_listener, this);
   while (!wayland_output_manager_ ||
          !wayland_output_manager_->IsOutputReady()) {
-    wl_display_roundtrip(display_.get());
+    wl_display_roundtrip_queue(display(), event_queue_.get());
   }
 
   buffer_manager_host_ = std::make_unique<WaylandBufferManagerHost>(this);
diff --git a/ui/ozone/platform/wayland/host/wayland_connection.h b/ui/ozone/platform/wayland/host/wayland_connection.h
index b7f2981a0748..9eac85e80ec7 100644
--- a/ui/ozone/platform/wayland/host/wayland_connection.h
+++ b/ui/ozone/platform/wayland/host/wayland_connection.h
@@ -16,6 +16,8 @@
 #include "ui/ozone/platform/wayland/host/wayland_data_source.h"
 #include "ui/ozone/platform/wayland/host/wayland_window_manager.h"
 
+struct wl_event_queue;
+
 namespace gfx {
 class Point;
 }
@@ -63,7 +65,17 @@ class WaylandConnection {
   // error. Called by WaylandEventWatcher.
   void SetShutdownCb(base::OnceCallback<void()> shutdown_cb);
 
+  // A correct display must be chosen when creating objects or calling
+  // roundrips.  That is, all the methods that deal with polling, pulling event
+  // queues, etc, must use original display. All the other methods that create
+  // various wayland objects must use |display_wrapper_| so that the new objects
+  // are associated with the correct event queue. Otherwise, they will use a
+  // default event queue, which we do not use. See the comment below about the
+  // |event_queue_|.
   wl_display* display() const { return display_.get(); }
+  wl_display* display_wrapper() const {
+    return reinterpret_cast<wl_display*>(wrapped_display_.get());
+  }
   wl_compositor* compositor() const { return compositor_.get(); }
   uint32_t compositor_version() const { return compositor_version_; }
   wl_subcompositor* subcompositor() const { return subcompositor_.get(); }
@@ -201,6 +213,8 @@ class WaylandConnection {
 
   uint32_t compositor_version_ = 0;
   wl::Object<wl_display> display_;
+  wl::Object<wl_proxy> wrapped_display_;
+  wl::Object<wl_event_queue> event_queue_;
   wl::Object<wl_registry> registry_;
   wl::Object<wl_compositor> compositor_;
   wl::Object<wl_subcompositor> subcompositor_;
diff --git a/ui/ozone/platform/wayland/host/wayland_connection_unittest.cc b/ui/ozone/platform/wayland/host/wayland_connection_unittest.cc
index cfce7dba9455..0a37efcd1c13 100644
--- a/ui/ozone/platform/wayland/host/wayland_connection_unittest.cc
+++ b/ui/ozone/platform/wayland/host/wayland_connection_unittest.cc
@@ -25,6 +25,7 @@ TEST(WaylandConnectionTest, Ping) {
   ASSERT_TRUE(server.Start(kXdgVersionStable));
   WaylandConnection connection;
   ASSERT_TRUE(connection.Initialize());
+  connection.event_source()->UseSingleThreadedPollingForTesting();
   connection.event_source()->StartProcessingEvents();
 
   base::RunLoop().RunUntilIdle();
diff --git a/ui/ozone/platform/wayland/host/wayland_data_device_base.cc b/ui/ozone/platform/wayland/host/wayland_data_device_base.cc
index 7df5d9ec7096..81761639d7de 100644
--- a/ui/ozone/platform/wayland/host/wayland_data_device_base.cc
+++ b/ui/ozone/platform/wayland/host/wayland_data_device_base.cc
@@ -65,7 +65,8 @@ void WaylandDataDeviceBase::ReadClipboardDataFromFD(
 void WaylandDataDeviceBase::RegisterDeferredReadCallback() {
   DCHECK(!deferred_read_callback_);
 
-  deferred_read_callback_.reset(wl_display_sync(connection_->display()));
+  deferred_read_callback_.reset(
+      wl_display_sync(connection_->display_wrapper()));
 
   static const wl_callback_listener kListener = {
       WaylandDataDeviceBase::DeferredReadCallback};
diff --git a/ui/ozone/platform/wayland/host/wayland_event_source.cc b/ui/ozone/platform/wayland/host/wayland_event_source.cc
index 15eb6b6e2c20..9bb4826d9d8a 100644
--- a/ui/ozone/platform/wayland/host/wayland_event_source.cc
+++ b/ui/ozone/platform/wayland/host/wayland_event_source.cc
@@ -62,9 +62,11 @@ WaylandEventSource::TouchPoint::TouchPoint(gfx::PointF location,
 // WaylandEventSource implementation
 
 WaylandEventSource::WaylandEventSource(wl_display* display,
+                                       wl_event_queue* event_queue,
                                        WaylandWindowManager* window_manager)
     : window_manager_(window_manager),
-      event_watcher_(std::make_unique<WaylandEventWatcher>(display)) {
+      event_watcher_(
+          std::make_unique<WaylandEventWatcher>(display, event_queue)) {
   DCHECK(window_manager_);
 
   // Observes remove changes to know when touch points can be removed.
@@ -77,12 +79,12 @@ void WaylandEventSource::SetShutdownCb(base::OnceCallback<void()> shutdown_cb) {
   event_watcher_->SetShutdownCb(std::move(shutdown_cb));
 }
 
-bool WaylandEventSource::StartProcessingEvents() {
-  return event_watcher_->StartProcessingEvents();
+void WaylandEventSource::StartProcessingEvents() {
+  event_watcher_->StartProcessingEvents();
 }
 
-bool WaylandEventSource::StopProcessingEvents() {
-  return event_watcher_->StopProcessingEvents();
+void WaylandEventSource::StopProcessingEvents() {
+  event_watcher_->StopProcessingEvents();
 }
 
 void WaylandEventSource::OnKeyboardCreated(WaylandKeyboard* keyboard) {
@@ -343,6 +345,10 @@ void WaylandEventSource::ResetPointerFlags() {
   pointer_flags_ = 0;
 }
 
+void WaylandEventSource::UseSingleThreadedPollingForTesting() {
+  event_watcher_->UseSingleThreadedPollingForTesting();
+}
+
 void WaylandEventSource::OnDispatcherListChanged() {
   StartProcessingEvents();
 }
diff --git a/ui/ozone/platform/wayland/host/wayland_event_source.h b/ui/ozone/platform/wayland/host/wayland_event_source.h
index dfda62810e58..1995ca481a34 100644
--- a/ui/ozone/platform/wayland/host/wayland_event_source.h
+++ b/ui/ozone/platform/wayland/host/wayland_event_source.h
@@ -49,7 +49,9 @@ class WaylandEventSource : public PlatformEventSource,
                            public WaylandPointer::Delegate,
                            public WaylandTouch::Delegate {
  public:
-  WaylandEventSource(wl_display* display, WaylandWindowManager* window_manager);
+  WaylandEventSource(wl_display* display,
+                     wl_event_queue* event_queue,
+                     WaylandWindowManager* window_manager);
   WaylandEventSource(const WaylandEventSource&) = delete;
   WaylandEventSource& operator=(const WaylandEventSource&) = delete;
   ~WaylandEventSource() override;
@@ -67,9 +69,9 @@ class WaylandEventSource : public PlatformEventSource,
   // Starts polling for events from the wayland connection file descriptor.
   // This method assumes connection is already estabilished and input objects
   // are already bound and properly initialized.
-  bool StartProcessingEvents();
+  void StartProcessingEvents();
   // Stops polling for events from input devices.
-  bool StopProcessingEvents();
+  void StopProcessingEvents();
 
   // Tells if pointer |button| is currently pressed.
   bool IsPointerButtonPressed(EventFlags button) const;
@@ -79,6 +81,9 @@ class WaylandEventSource : public PlatformEventSource,
   // button released event is not delivered (e.g: window moving, drag and drop).
   void ResetPointerFlags();
 
+  // See the comment near WaylandEventWatcher::use_dedicated_polling_thread_.
+  void UseSingleThreadedPollingForTesting();
+
  protected:
   // WaylandKeyboard::Delegate
   void OnKeyboardCreated(WaylandKeyboard* keyboard) override;
diff --git a/ui/ozone/platform/wayland/host/wayland_event_watcher.cc b/ui/ozone/platform/wayland/host/wayland_event_watcher.cc
index 9fd65bd9afa9..cfafe9905ba6 100644
--- a/ui/ozone/platform/wayland/host/wayland_event_watcher.cc
+++ b/ui/ozone/platform/wayland/host/wayland_event_watcher.cc
@@ -4,60 +4,130 @@
 
 #include "ui/ozone/platform/wayland/host/wayland_event_watcher.h"
 
+#include <cstring>
+
 #include "base/bind.h"
+#include "base/callback_forward.h"
 #include "base/check.h"
+#include "base/logging.h"
+#include "base/macros.h"
 #include "base/task/current_thread.h"
+#include "base/threading/thread.h"
+#include "base/threading/thread_task_runner_handle.h"
 #include "ui/events/event.h"
 #include "ui/ozone/platform/wayland/common/wayland.h"
 
 namespace ui {
 
-WaylandEventWatcher::WaylandEventWatcher(wl_display* display)
-    : controller_(FROM_HERE), display_(display) {
-  DCHECK(display_);
+namespace {
+
+void DispatchPending(wl_display* display, wl_event_queue* event_queue) {
+  wl_display_dispatch_queue_pending(display, event_queue);
 }
 
-WaylandEventWatcher::~WaylandEventWatcher() {
-  StopProcessingEvents();
+}  // namespace
+
+// A dedicated thread for watching wl_display's file descriptor. The reason why
+// watching happens on a separate thread is that the thread mustn't be blocked.
+// Otherwise, if Chromium is used with Wayland EGL, a deadlock may happen. The
+// deadlock happened when the thread that had been watching the file descriptor
+// (it used to be the browser's UI thread) called wl_display_prepare_read, and
+// then started to wait until the thread, which was used by the gpu service,
+// completed a buffer swap and shutdowned itself (for example, a menu window is
+// in the process of closing). However, that gpu thread hanged as it called
+// Wayland EGL that also called wl_display_prepare_read internally and started
+// to wait until the previous caller of the wl_display_prepare_read (that's by
+// the design of the wayland-client library). This situation causes a deadlock
+// as the first caller of the wl_display_prepare_read is unable to complete
+// reading as it waits for another thread to complete, and that another thread
+// is also unable to complete reading as it waits until the first caller reads
+// the display's file descriptor. For more details, see the implementation of
+// the wl_display_prepare_read in third_party/wayland/src/src/wayland-client.c.
+class WaylandEventWatcherThread : public base::Thread {
+ public:
+  explicit WaylandEventWatcherThread(
+      base::OnceClosure start_processing_events_cb)
+      : base::Thread("wayland-fd"),
+        start_processing_events_cb_(std::move(start_processing_events_cb)) {}
+  ~WaylandEventWatcherThread() override { Stop(); }
+
+  void Init() override {
+    DCHECK(!start_processing_events_cb_.is_null());
+    std::move(start_processing_events_cb_).Run();
+  }
+
+ private:
+  base::OnceClosure start_processing_events_cb_;
+};
+
+WaylandEventWatcher::WaylandEventWatcher(wl_display* display,
+                                         wl_event_queue* event_queue)
+    : controller_(FROM_HERE),
+      display_(display),
+      event_queue_(event_queue),
+      ui_thread_task_runner_(base::ThreadTaskRunnerHandle::Get()) {
+  DCHECK(display_);
 }
 
+WaylandEventWatcher::~WaylandEventWatcher() = default;
+
 void WaylandEventWatcher::SetShutdownCb(
     base::OnceCallback<void()> shutdown_cb) {
   DCHECK(shutdown_cb_.is_null());
   shutdown_cb_ = std::move(shutdown_cb);
 }
 
-bool WaylandEventWatcher::StartProcessingEvents() {
-  DCHECK(display_);
-  if (watching_)
-    return true;
-
-  DCHECK(display_);
-  MaybePrepareReadQueue();
-  wl_display_flush(display_);
-  return StartWatchingFd(base::MessagePumpForUI::WATCH_READ);
+void WaylandEventWatcher::StartProcessingEvents() {
+  if (use_dedicated_polling_thread_ && !thread_) {
+    // FD watching will happen on a different thread.
+    DETACH_FROM_THREAD(thread_checker_);
+
+    thread_.reset(new WaylandEventWatcherThread(
+        base::BindOnce(&WaylandEventWatcher::StartProcessingEventsInternal,
+                       weak_factory_.GetWeakPtr())));
+    base::Thread::Options thread_options;
+    thread_options.message_pump_type = base::MessagePumpType::UI;
+    thread_options.priority = base::ThreadPriority::DISPLAY;
+    if (!thread_->StartWithOptions(thread_options))
+      LOG(FATAL) << "Failed to create input thread";
+
+  } else if (!use_dedicated_polling_thread_) {
+    StartProcessingEventsInternal();
+  }
 }
 
-bool WaylandEventWatcher::StopProcessingEvents() {
+void WaylandEventWatcher::StopProcessingEvents() {
   if (!watching_)
-    return false;
+    return;
 
-  DCHECK(base::CurrentUIThread::IsSet());
-  watching_ = false;
-  return controller_.StopWatchingFileDescriptor();
+  if (use_dedicated_polling_thread_) {
+    watching_thread_task_runner_->PostTask(
+        FROM_HERE,
+        base::BindOnce(&WaylandEventWatcher::StopProcessingEventsInternal,
+                       weak_factory_.GetWeakPtr()));
+  } else {
+    StopProcessingEventsInternal();
+  }
+}
+
+void WaylandEventWatcher::UseSingleThreadedPollingForTesting() {
+  use_dedicated_polling_thread_ = false;
 }
 
 void WaylandEventWatcher::OnFileCanReadWithoutBlocking(int fd) {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (!CheckForErrors()) {
-    StopProcessingEvents();
+    StopProcessingEventsInternal();
     return;
   }
 
   if (prepared_) {
     prepared_ = false;
+    // Errors will be checked the next time OnFileCanReadWithoutBlocking calls
+    // CheckForErrors.
     if (wl_display_read_events(display_) == -1)
       return;
-    wl_display_dispatch_pending(display_);
+    DispatchPendingQueue();
   }
 
   MaybePrepareReadQueue();
@@ -77,6 +147,7 @@ void WaylandEventWatcher::OnFileCanReadWithoutBlocking(int fd) {
 }
 
 void WaylandEventWatcher::OnFileCanWriteWithoutBlocking(int fd) {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   int ret = wl_display_flush(display_);
   if (ret != -1 || errno != EAGAIN)
     StartWatchingFd(base::MessagePumpForUI::WATCH_READ);
@@ -86,8 +157,33 @@ void WaylandEventWatcher::OnFileCanWriteWithoutBlocking(int fd) {
   // Otherwise just continue watching in the same mode.
 }
 
-bool WaylandEventWatcher::StartWatchingFd(
+void WaylandEventWatcher::StartProcessingEventsInternal() {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  DCHECK(display_);
+  if (watching_)
+    return;
+
+  watching_thread_task_runner_ = base::ThreadTaskRunnerHandle::Get();
+
+  DCHECK(display_);
+  MaybePrepareReadQueue();
+  wl_display_flush(display_);
+  StartWatchingFd(base::MessagePumpForUI::WATCH_READ);
+}
+
+void WaylandEventWatcher::StopProcessingEventsInternal() {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  if (!watching_)
+    return;
+
+  DCHECK(base::CurrentUIThread::IsSet());
+  watching_ = !controller_.StopWatchingFileDescriptor();
+  DCHECK(!watching_);
+}
+
+void WaylandEventWatcher::StartWatchingFd(
     base::WatchableIOMessagePumpPosix::Mode mode) {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (watching_) {
     // Stop watching first.
     watching_ = !controller_.StopWatchingFileDescriptor();
@@ -98,22 +194,36 @@ bool WaylandEventWatcher::StartWatchingFd(
   int display_fd = wl_display_get_fd(display_);
   watching_ = base::CurrentUIThread::Get()->WatchFileDescriptor(
       display_fd, true, mode, &controller_, this);
-  return watching_;
+  CHECK(watching_) << "Unable to start watching the wl_display's file "
+                      "descriptor.";
 }
 
 void WaylandEventWatcher::MaybePrepareReadQueue() {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (prepared_)
     return;
 
-  if (wl_display_prepare_read(display_) != -1) {
+  if (wl_display_prepare_read_queue(display_, event_queue_) != -1) {
     prepared_ = true;
     return;
   }
   // Nothing to read, send events to the queue.
-  wl_display_dispatch_pending(display_);
+  DispatchPendingQueue();
+}
+
+void WaylandEventWatcher::DispatchPendingQueue() {
+  if (ui_thread_task_runner_->BelongsToCurrentThread()) {
+    DCHECK(!use_dedicated_polling_thread_);
+    DispatchPending(display_, event_queue_);
+  } else {
+    DCHECK(use_dedicated_polling_thread_);
+    auto cb = base::BindOnce(&DispatchPending, display_, event_queue_);
+    ui_thread_task_runner_->PostTask(FROM_HERE, std::move(cb));
+  }
 }
 
 bool WaylandEventWatcher::CheckForErrors() {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   int err = wl_display_get_error(display_);
   if (err == EPROTO) {
     // This can be null in tests.
diff --git a/ui/ozone/platform/wayland/host/wayland_event_watcher.h b/ui/ozone/platform/wayland/host/wayland_event_watcher.h
index 6a13ea92f4bc..2e52a43af187 100644
--- a/ui/ozone/platform/wayland/host/wayland_event_watcher.h
+++ b/ui/ozone/platform/wayland/host/wayland_event_watcher.h
@@ -6,10 +6,18 @@
 #define UI_OZONE_PLATFORM_WAYLAND_HOST_WAYLAND_EVENT_WATCHER_H_
 
 #include "base/callback.h"
+#include "base/memory/weak_ptr.h"
 #include "base/message_loop/message_pump_for_ui.h"
 #include "base/message_loop/watchable_io_message_pump_posix.h"
+#include "base/threading/thread_checker.h"
 
 struct wl_display;
+struct wl_event_queue;
+
+namespace base {
+class Thread;
+class SingleThreadTaskRunner;
+}  // namespace base
 
 namespace ui {
 
@@ -19,7 +27,7 @@ namespace ui {
 // into WaylandEventSource, so feeding the platform events pipeline.
 class WaylandEventWatcher : public base::MessagePumpForUI::FdWatcher {
  public:
-  explicit WaylandEventWatcher(wl_display* display);
+  WaylandEventWatcher(wl_display* display, wl_event_queue* event_queue);
   WaylandEventWatcher(const WaylandEventWatcher&) = delete;
   WaylandEventWatcher& operator=(const WaylandEventWatcher&) = delete;
   ~WaylandEventWatcher() override;
@@ -31,18 +39,24 @@ class WaylandEventWatcher : public base::MessagePumpForUI::FdWatcher {
   // Starts polling for events from the wayland connection file descriptor.
   // This method assumes connection is already estabilished and input objects
   // are already bound and properly initialized.
-  bool StartProcessingEvents();
+  void StartProcessingEvents();
 
   // Stops polling for events from input devices.
-  bool StopProcessingEvents();
+  void StopProcessingEvents();
+
+  // See the comment near WaylandEventWatcher::use_dedicated_polling_thread_.
+  void UseSingleThreadedPollingForTesting();
 
  private:
   // base::MessagePumpForUI::FdWatcher
   void OnFileCanReadWithoutBlocking(int fd) override;
   void OnFileCanWriteWithoutBlocking(int fd) override;
 
-  bool StartWatchingFd(base::WatchableIOMessagePumpPosix::Mode mode);
+  void StartProcessingEventsInternal();
+  void StopProcessingEventsInternal();
+  void StartWatchingFd(base::WatchableIOMessagePumpPosix::Mode mode);
   void MaybePrepareReadQueue();
+  void DispatchPendingQueue();
 
   // Checks if |display_| has any error set. If so, |shutdown_cb_| is executed
   // and false is returned.
@@ -51,11 +65,38 @@ class WaylandEventWatcher : public base::MessagePumpForUI::FdWatcher {
   base::MessagePumpForUI::FdWatchController controller_;
 
   wl_display* const display_;  // Owned by WaylandConnection.
+  wl_event_queue* const event_queue_;  // Owned by WaylandConnection.
 
   bool watching_ = false;
   bool prepared_ = false;
 
+  // A separate thread is not used in some tests (ozone_unittests), as it
+  // requires additional synchronization from the WaylandTest side. Otherwise,
+  // some tests complete without waiting until events come. That is, the tests
+  // suppose that our calls/requests are completed after calling Sync(), which
+  // resumes our fake Wayland server and sends out events, but as long as there
+  // is one additional "polling" thread involved, some additional
+  // synchronization mechanisms are needed. At this point, it's easier to
+  // continue to watch the file descriptor on the same thread where the
+  // ozone_unittests run.
+  bool use_dedicated_polling_thread_ = true;
+
   base::OnceCallback<void()> shutdown_cb_;
+
+  // Used to verify watching the fd happens on a valid thread.
+  THREAD_CHECKER(thread_checker_);
+
+  // See the |use_dedicated_polling_thread_| and also the comment in the source
+  // file for this header.
+  std::unique_ptr<base::Thread> thread_;
+
+  // The original ui task runner where |this| has been created.
+  scoped_refptr<base::SingleThreadTaskRunner> ui_thread_task_runner_;
+
+  // The thread's task runner where the wl_display's fd is being watched.
+  scoped_refptr<base::SingleThreadTaskRunner> watching_thread_task_runner_;
+
+  base::WeakPtrFactory<WaylandEventWatcher> weak_factory_{this};
 };
 
 }  // namespace ui
diff --git a/ui/ozone/platform/wayland/host/wayland_keyboard.cc b/ui/ozone/platform/wayland/host/wayland_keyboard.cc
index 7b1e06e7ad51..802d72908b18 100644
--- a/ui/ozone/platform/wayland/host/wayland_keyboard.cc
+++ b/ui/ozone/platform/wayland/host/wayland_keyboard.cc
@@ -176,7 +176,7 @@ void WaylandKeyboard::FlushInput(base::OnceClosure closure) {
   // wl_display_sync gives a chance for any key "up" events to arrive.
   // With a well behaved wayland compositor this should ensure we never
   // get spurious repeats.
-  sync_callback_.reset(wl_display_sync(connection_->display()));
+  sync_callback_.reset(wl_display_sync(connection_->display_wrapper()));
   wl_callback_add_listener(sync_callback_.get(), &callback_listener_, this);
   connection_->ScheduleFlush();
 }
diff --git a/ui/ozone/platform/wayland/host/wayland_zaura_shell_unittest.cc b/ui/ozone/platform/wayland/host/wayland_zaura_shell_unittest.cc
index a8bba1eb24dd..6c45841d01fe 100644
--- a/ui/ozone/platform/wayland/host/wayland_zaura_shell_unittest.cc
+++ b/ui/ozone/platform/wayland/host/wayland_zaura_shell_unittest.cc
@@ -33,6 +33,7 @@ TEST(WaylandZauraShellTest, Foo) {
 
   WaylandConnection connection;
   ASSERT_TRUE(connection.Initialize());
+  connection.event_source()->UseSingleThreadedPollingForTesting();
   connection.event_source()->StartProcessingEvents();
 
   base::RunLoop().RunUntilIdle();
diff --git a/ui/ozone/platform/wayland/test/wayland_test.cc b/ui/ozone/platform/wayland/test/wayland_test.cc
index 58e395d8e82d..b3f5b1378d0a 100644
--- a/ui/ozone/platform/wayland/test/wayland_test.cc
+++ b/ui/ozone/platform/wayland/test/wayland_test.cc
@@ -11,6 +11,7 @@
 #include "ui/events/ozone/layout/keyboard_layout_engine_manager.h"
 #include "ui/events/ozone/layout/scoped_keyboard_layout_engine.h"
 #include "ui/ozone/common/features.h"
+#include "ui/ozone/platform/wayland/host/wayland_event_source.h"
 #include "ui/ozone/platform/wayland/host/wayland_output_manager.h"
 #include "ui/ozone/platform/wayland/host/wayland_screen.h"
 #include "ui/ozone/platform/wayland/test/mock_surface.h"
@@ -60,6 +61,7 @@ void WaylandTest::SetUp() {
 
   ASSERT_TRUE(server_.Start(GetParam()));
   ASSERT_TRUE(connection_->Initialize());
+  connection_->event_source()->UseSingleThreadedPollingForTesting();
   screen_ = connection_->wayland_output_manager()->CreateWaylandScreen(
       connection_.get());
   EXPECT_CALL(delegate_, OnAcceleratedWidgetAvailable(_))
-- 
2.25.1

